<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>My Website(Report(1))</title>
    <script src="script.js"></script>
    <style>
        @font-face {
            font-family:'Lightda';
            font-style: normal;
            font-weight: 400;
            src: url('./fonts/Li.eot');
            src: url('./fonts/Li.eot?#iefix') format('embedded-opentype'),
                 url('./fonts/Li.woff') format('woff');
        }

        @font-face {
        	font-family: 'paper';
        	font-style: normal;
        	font-weight: 200;
        	src: url('./fonts/paper.eot');
        	src: url('./fonts/paper.eot?#iefix') format('embedded-opentype'),
        		 url('./fonts/paper.woff') format('woff');
        }

        /* Reset some default styles */
        body, h1, h2, p, ul, li {
          margin: 0;
          padding: 0;
        }

        /* Define basic styles */
        body {
          font-family: Arial, sans-serif;
          line-height: 1.6;
        }

        header {
          background-color: #000;
          color: #fff;
          padding: 20px;
        }

        nav ul {
          list-style-type: none;
        }

        nav li {
          display: inline;
          margin-right: 10px;
        }

        .htitle {
        	text-align: center;
        	padding: 40px;
        	background-color: #f8f8f8;
        }

        .hero {
          text-align: center;
          padding: 80px;
          background-color: #e0e0e0;
        }

        .content {
          padding: 40px;
        }

        .container {
        	display: flex;
        }

        .left-column {
        	flex: 1;
        	padding: 20px;
        	background-color: #f2f2f2;
        	border-style: solid;
        	border-color: black;
        }

        .right-column {
        	flex: 1;
        	padding: 20px;
        	background-color: #f2f2f2;
        	border-style: solid;
        	border-color: black;
        }

        .bor {
        	border-style: solid;
        	border-color: black;
        }

        form input, textarea, button {
          display: block;
          margin-bottom: 10px;
          width: 100%;
          padding: 10px;
        }

        footer {
          background-color: #000;
          color: #fff;
          padding: 10px;
          text-align: center;
        }
    </style>
</head>
<body style="font-family: 'Lightda';">
    <header>
        <h1 style="color: lightgreen">20307 report</h1>
        <nav>
            <ul>
                <li><a href="../index.html">Home</a></li>
            </ul>
        </nav>
    </header>
    <div class="wrapper">
	    <section>
	    	<div class="hero">
	    		<h1 style="font-size: 41px">로그 함수의 해석적 연속</h1>
	    		<h1 style="font-size: 20px">Analytic continuation of log function</h1>
	    	</div>
	    </section>
	    <section>
	    	<div class="container">
	    		<div class="left-column">
	    			<ul><li><h1>동기</h1></li></ul>
	    			<p style="margin-bottom: 50px;">2학년 수학시간에 로그 함수에 대해 배웠다. 여기서 로그 함수는 지수함수의 역함수로 정의되거나 그냥 정의하는 방법을 사용하여 정의하였다. 그런데 이러한 로그 함수의 정의역은 단지 양의 실수로밖에 한정이 되어있어서 정의역을 음의 실수로 확장시키기 위해서는 어떤게 필요할까 고민하였다. 마침 그때 수학의 분야 중 하나인 복소해석학을 맛보던 중이었기 때문에 우연히 해석적 확장(Analytic continuation)에 대해 알게 되었고 그로 인해 본래 정의가 되지 않던 함숫값을 정의역을 확장시킴으로써 여러 신기한 결과들을 도출해냈다는 것을 알게 되어서 본 보고서에서는 복소 로그 함수에 대해 다룰 예정이다.</p>
	    			<ul>
	    				<li><h1>탐구방법</h1></li>
	    				<li><h3>1. 본 보고서에 요구되는 여러가지 수학적 개념에 대해 간단히 조사한다.</h3></li>
	    				<li><h3>2. (1)에서 조사한 개념들을 활용하여 복소 로그 함수에 대해 구체적으로 정의한다. </h3></li>
	    				<li><h3>3. 복소 로그 함수의 응용 사례(수학적 측면과 공학적 측면)들을 찾아본다.</h3></li>
	    			</ul>
	    		</div>
	    		<div class="right-column">
	    			<ul>
	    				<li><h1>목차</h1></li>
	    				<li><h3>1. 여러가지 수학적 개념</h3></li>
	    					<p style="margin-right: 20px;">- 1.1 복소수(complex number)</p>
	    					<p style="margin-right: 20px;">- 1.2 해석 함수(analytic function)</p>
	    					<p style="margin-right: 20px;">- 1.3 해석적 확장(analytic continuation)</p>
	    				<li><h3>2. 복소 로그 함수</h3></li>
	    					<p style="margin-right: 20px;">- 2.1 복소 로그 함수의 정의</p>
	    					<p style="margin-right: 20px;">- 2.2 실수 로그함수와의 비교</p>
	    				<li><h3>3. 응용 사례(수학적 측면 and 공학적 측면)</h3></li>
	    					<p style="margin-right: 20px;"></p>
	    				<li><h3>4. 소감</h3></li>
	    				<li><h3>5. 참고 문헌</h3></li>
	    			</ul>

	    		</div>
	    	</div>
	    </section>
	    <div style="border-style: solid;border-color: black;">
		    <section>
		    	<div class="content">
		    		<ul><li><h3 style="font-size: 30px;">여러가지 수학적 개념</h3></li></ul>
			    		<h3 style="font-size: 22px">1. 복소수(Complex Number)</h3>
			    		<ol>
			    			<li>
			    				<h1 style="font-size: 18px">복소수의 정의</h1>
			    				<p style="margin-bottom: 10px;">
			    					- 복소수(complex number)는 두 실수의 순서쌍 (x, y)로 정의할 수 있다. 
			    					순서쌍 (x, y)는 복소 평면(complex plane)에서 직교 좌표가 x, y인 좌표로 해석한다. 
			    					따라서 만약 (x, 0)이라면 이는 실수의 집합임을 알 수 있고, (0, y)는 순허수(pure imaginary number)라 한다. 
			    					x는 실수 축(real axis), y는 허수 축(imaginary axis)이라고 한다. 보통 복소수 (x, y)를 z로 나타낸다. 
			    					또 두 실수 x, y를 각각 z의 실수 부분(real part)와 허수 부분(imaginary part) 라 한다. 그리고 다음과 같은 기호로 나타낸다.
			    					<br>
			    					Re(z) = x, Im(z) = y
			    					<br>
			    					<br>
			    					- 복소수 z를 다음과 같이 나타내기도 한다.<br>
			    					z = x + iy
			    				</p>
			    			</li>
			    			<li>
			    				<h1 style="font-size: 18px">복소수의 합과 곱</h1>
			    				<p style="margin-bottom: 10px">
			    					- z1 = (x1, y1), z2 = (x2, y2)의 합(sum) z1 + z2 곱(product) z1z2를 다음과 같이 정의한다.<br>
			    					① (x1, y1) + (x2, y2) = (x1 + x2, y1 + y2)<br>
			    					② (x1, y1)(x2, y2) = (x1x2 - y1y2, y1x2 + x1y2)
			    				</p>
			    			</li>
			    			<li>
			    				<h1 style="font-size: 18px">지수 형식</h1>
			    				<p style="margin-bottom: 10px;">
			    					- 복소수 z에 대응하는 점 (x, y)의 극 좌표를 (r, θ)라 하자. 
			    					x = rcos(θ), y = rsin(θ)이므로 z를 다음과 같이 나타낼 수 있다.(단, z=0일때 θ는 정의되지 않는다.) 
			    					그리고 복소해석학에서 r은 z에 대한 동경 벡터의 길이를 나타내므로 r = |z|이다.<br>
			    					z = r(cos(θ) + sin(θ))<br><br>
			    					- 실수 θ는 동경 벡터로 해석할 때, z가 양의 실수 축과 이루는 각의 크기를 라디안으로 나타낸 값이다. 
			    					θ의 각 값을 z의 편각(argument)이라 하고, 이런 값 전체의 집합을 arg(z)라 나타낸다. 
			    					z의 편각 중 (-π, π]에 속하는 유일한 값 θ를 arg(z)의 주값(principal value)이라 하며, Arg(z)라 나타낸다.<br><br>
			    					-기호 exp(iθ)를 오일러의 공식(Euler's formula)을 이용하여 다음과 같이 정의한다.<br>
			    					exp(iθ) = cos(θ) + isin(θ)
			    				</p>
			    			</li>		    					    			
			    		</ol>
		    	</div>
		    </section>
		    <section>
		    	<div class="content">
		    		<h3 style="font-size: 22px">2. 해석 함수(Analytic function)</h3>
		    		<ol>
		    			<li>
		    				<h1 style="font-size: 18px">복소 변수 함수</h1>
		    				<p style="margin-bottom: 10px">
		    					- S를 복소수 전체 집합의 부분 집합이라 하자. 그러면 S에서 정의된 함수 f는 S에 속한 각 원소 z에 복소수 w를 대응시키는 규칙이다. 
		    					수 w를 z에서 f의 값 또는 함숫값이라 하고, f(z)라 나타낸다.	
		    					그러므로 w = f(z)이다. 
		    					집합 S를 f의 정의역(domain of definition)이라고 한다. 
		    					다음과 같이 w = u + iv를 z = x + iy에서 함수 f의 값이라고 하자. <br>
		    					u + iv = f(x + iy) <br>
		    					그러면 u, v는 두 실수 변수 x, y에 의해 결정되고 이에 따라 다음과 같이 나타낼수 있다. <br>
		    					f(z) = u(x, y) + iv(x, y) <br>
		    					x, y 대신에 r과 θ를 사용하면, 다음과 같다. <br>
		    					f(z) = u(r, θ) + iv(r, θ)
		    				</p>
		    			</li>
		    			<li>
		    				<h1 style="font-size: 18px">극한</h1>
		    				<p style="margin-bottom: 10px">
		    					- 약한 극한의 정의 <br>
		    					: 함수 f는 z0의 한 빠진 이웃에 속한 모든 점 z에서 잘 정의되어 있다고 하자. z0이 아닌면서 이에 충분히 가까운 점 z를 선택하면 점 w = f(z)를 w0에 임의로 가깝게 할 수 있을 때, z가 z0에 가까워질 때, f(z)의 극한(limit)은 w0이라고 한다.
		    					<br>
		    					<br>
		    					- 엄밀한 극한의 정의 <br>
		    					: 함수 f에 대해 0 < |z - z0| < δ 이면, |f(z) - w0| < ε 이라고 하자. 그러면, z가 z0에 가까워질 때, f(z)의 극한은 w0이라고 한다.  <br>
		    				</p>
		    			</li>
		    			<li>
		    				<h1 style="font-size: 18px">해석 함수</h1>
		    				<p style="margin-bottom: 10px">
		    					- ε근방 <br>
		    					: |z - z0| < ε을 만족하는 원소들의 집합 <br>
		    					- 미분 <br>
		    					: 함수 f의 정의역은 점 z0의 근방 |z - z0| < ε을 포함한다고 하자. z0에서 f의 도함수는 다음과 같은 극한이다. <br>
		    					lim(z->z0)((f(z)-f(z0))/(z-z0)) <br>
		    					- 해석 함수 <br>
		    					: 복소 변수 z의 함수 f를 점 z0의 어떤 이웃에 속한 모든 점에서 미분할 수 있을 때, f는 점 z0에서 해석적(analytic at a point z0)이라고 한다. 
		    					이에 따라 g가 z0에서 해석적이면, f는 z0의 어떤 이웃에 속한 모든점에서 해석적이다.
		    					f가 만약 한 열린 집합의 모든 점에서 미분가능할 때, f는 그 열린 집합에서 해석적이라고 한다.
		    				</p>
		    			</li>
		    		</ol>
		    	</div>
		    </section>
		    <section>
		    	<div class="content">
		    		<h3 style="font-size: 22px">3. 해석적 확장(analytic continuation)</h3>
		    		<ol>
		    			<li>
		    				<h1 style="font-size: 18px">보조 정리</h1>
		    				<p style="margin-bottom: 10px">
		    					- 다음을 만족한다고 하자. <br>
		    					① 함수 f는 영역 D 전체에서 해석적이다. <br>
		    					② D에 포함되는 한 영역 또는 선분의 모든 점 z에서 f(z) = 0이다. <br>
		    					그러면 D에서 f(z) = 0이다. 곧, f(z)는 D의 모든 점에서 언제나 0이다.
		    				</p>
		    			</li>
		    			<li>
		    				<h1 style="font-size: 18px">증명</h1>
		    				<p style="margin-bottom: 10px">
		    					- 모든 점에서 f(z) = 0인 부분 영역 또는 선분의 임의의 점을 z0이라고 하자. D는 열린 연결 집합이므로 z0과 D의 다른 임의의 점 P를 연결하는 꺽인 선 L이 존재한다. D가 평면 전체가 아니면, L에 있는 점으로부터 D의 경계까지의 가장 짧은 거리를 d라고 하자. D가 평면 전체인 경우 d를 임의의 양수로 선택할 수 있다. 그리고 L에 있는 유한개의 점으로 염을 형성하자. <br>
		    					z0, z1, z2, ... , zn <br>
		    					여기서 각 점은 다음을 만족한다. <br>
		    					|zk - z(k-1)| < d (k = 1, 2, ..., n) <br>
		    					마지막으로 다음과 같이 유한개의 이웃으로 열을 구성하자. <br>
		    					N0, N1, N2, ..., Nn <br>
		    					이때, 각 이웃 Nk는 중심이 zk이고 반지름이 d이다. 이런 이웃은 모두 D에 포함되고 k = 1, 2, ..., n에 대해 이웃 Nk의 중심 zk는 직전 이웃 N(k-1)에 속한다.
		 						f는 영역 N0에서 해석적이고 z0을 포함하는 영역이나 선분에서 f(z) = 0이므로, N0에서 f(z) = 0이다. 이와 같은 방식으로 Nk에 대하여 적용하면 Nn에서 f(z) = 0이다. 따라서 이 보조 정리는 참이다.
		    				</p>
		    			</li>
		    			<li>
		    				<h1 style="font-size: 18px">정리</h1>
		    				<p style="margin-bottom: 10px">
		    					- 영역 D에서 해석적이 함수는 D에 포함되는 한 영역 또는 선분에서의 함숫값에 의해 D 전체에서 유일하게 결정된다.
		    				</p>
		    			</li>
		    			<li>
		    				<h1 style="font-size: 18px">해석적 확장(analytic continuation)</h1>
		    				<p style="margin-bottom: 10px">
		    					- 주어진 두 영역 D1과 D2에 대해서 D1과 D2에 모두 속한 점 전체로 이루어진 교집합을 생각하자. D1과 D2에 모두 속한 점이 있고, 함수 f1은 D1에서 해석적이면, D2에서 해석적인 함수 f2가 존재해서 교집합에 속하는 모든 점 z에 대해 f1(z) = f2(z)가 성립할 수 있다. 이 때, f2를 둘째 영역 D2로의 f1의 해석적 확장(analytic continuation)이라고 한다.
		    				</p>
		    		</ol>
		    	</div>
		    </section>
		    <section>
		    	<div class="content">
		    		<ul><li><h3 style="font-size: 30px;">복소 로그 함수의 정의</h3></li></ul>
		    		<ol>
		    			<li>
		    				<h1 style="font-size: 18px">복소 로그 함수</h3>
		    				<p style="margin-bottom: 10px;">
		    					- 복소 로그 함수는 실수 로그 함수를 해석적 확장하여 정의한다. 먼저 두 복소수 z, w에 대하여 다음 식을 푸는 것으로 얻을 수 있다. <br>
		    					exp(w) = z (z는 0이 아닌 복소수) <br>
		    					이제, z = rexp(iθ) (-π < θ <=π), w = u + iv로 나타내자. 그러면 exp(u) = r, v = θ + 2nπ (n은 임의의 정수)가 성립한다. 따라서 위 식이 성립할 필요 충분 조건은 w = ln(r) + i(θ + 2nπ) (n = ..., -1, 0, 1, ...)이다.
		    					그래서 log(z) = ln(r) + i(θ + 2nπ) (n = ..., -1, 0, 1, ...)이라 나타낼 수 있다고 하자. 그러면 exp(log(z))=z (z != 0)을 얻는다. 이 식은 영이 아닌 복소 변수 z에 관한 (다가) 로그 함수의 정의로 받아들인다. <br><br>
		    					-복소 로그 함수는 다가성을 띈다고 볼 수 있다. 다가성이란 정의역의 한 원소가 치역의 여러 개의 원소에 대응되는 것을 말한다. 예를 들어, z = -1-sqrt(3)i이라고 하자. 그러면 r = 2, θ = -2π/3이다. 따라서 복소 로그 함수는 다음과 같이 표현된다. <br>
		    					log(z) = log(-1-sqrt(3)i) = ln(2) + i(-2π/3 + 2nπ) = ln2 + 2(n-1/3)πi (n=..., -1, 0, 1, ...) <br>
		    					그러므로 log(z)의 주값을 정의한다. 이 주값은 log(z)에서 n = 0일때 얻는 값이며 기호로는 Log(z) = ln r + iθ이다. 이 함수는 z != 0일때, 잘 정의된 단가 함수이다.
		    				</p>
		    			</li>
		    			<li>
		    				<h1 style="font-size: 18px">실수 로그 함수와의 비교</h1>
		    				<p>
		    					- (여기서 복소 로그 함수는 log(z)의 주값을 의미한다.) 실수 로그 함수는 사실 복소 로그 함수가 z = r일 때의 Log(z)의 값과 동일하다. 이 결과는 본래 양의 실수상에서만 정의된던 함수를 복소수로 확장 하였음을 보여준다. 왜냐하면 실수 로그 함수는 정의역이 다음과 같음이 자명하다. <br>
		    					R = {x|x>0} <br>
		    					그리고 복소 로그 함수의 정의역은 다음과 같다. <br>
		    					C = {z|z != 0} <br>
		    					따라서 R∩C는 R과 같다. 그러므로 교집합 부분에서 실수 로그 함수와 복소 로그 함수와 완전히 동일하기 때문에 두 함수 모두 해석적이므로 이 실수 로그 함수의 해석적 확장은 복소 로그 함수이다.
		    				</p>
		    			</li>
		    		</ol>
		    	</div>
		    </section>
		    <section>
		    	<div class="content">
		    		<ul><li><h3 style="font-size: 30px"></h3></li></ul>
		    	</div>
		    </section>
		</div>
		<div style="border-style: solid;border-color: black;">
			<section>
				<div class="content">
					<ul><li><h3>사용되는 알고리즘의 결합</h3></li></ul>
					<p>- 사용할 알고리즘의 원리들은 Merge Sort, Bogo Sort, bubble Sort의 원리들을 이용해보자.
						<br>
						Merge Sort의 경우 리스트를 분할하여 재결합하는 원리를 사용하자. 그리고 분할을 실행하자.
						<br>
						이제 확률적인 관점에서 접근해보자. 리스트의 크기가 1이나 0으로 분할되면 그것들은 전부 정렬된 상태이다. 그리고 이를 결합시키자. (-Merge Sort의 원리 부분 채용)
						<br>
						결합을 시킬때 이를 랜덤하게 어떤 한 리스트를 선택한다. 그리고 그 리스트보다 더 큰 원소를 가진 것을 오른쪽에 배치하고 작은 원소를 가진 것을
						<br>
						왼쪽에 배치한다. 그리고 이 상태를 '아주 조금 정렬된 상태'라고 정의하자. 그리고 이 과정을 리스트의 크기에 따라(이 함수는 정확하게 결정되지 않음)
						<br>
						이 과정을 반복하여 '조금 정렬된 상태'를 만들자. 이제 부분적으로 Merge Sort처럼 리스트들을 결합한 뒤에 Bubble Sort를 리스트에 크기에 따른 함수에 맞춰 반복 실행시켜준다.
						<br>
						그러면 리스트를 '많이 정렬된 상태'를 만들 수 있다.
					</p>
				</div>
			</section>
			<section>
				<div class="content">
					<ul><li><h3>제작한 알고리즘의 결과물</h3></li></ul>
					<p>
						- 위 알고리즘은 정렬 알고리즘의 새로운 관점을 제시한다고 생각한다. 왜냐하면 위의 과정에 따르면 개인적으로 생각하는 많이 정렬된 상태인 리스트는 정렬하는 
						<br>
						방법을 생각하는 것은 여러가지 생각할 수 있다 생각했다. 또한 확률적 밀러-라빈 소수판별 알고리즘의 경우처럼 수학적인 원리를 사용하면 적은 반복을 통하여 리스트를
						<br>
						많이 정렬된 상태로 만들 수 있다고 생각한다. 여기서 만든 알고리즘의 시간복잡도는 O(n*f(n))인데 여기서 f(n)을 log(n)보다 작게 만들 수 있으면 기존의 리스트를
						<br>
						정렬하는 것보다 훨씬 빠르게 만들 수 있다고 생각한다. 그리고 사실 이것은 정렬 함수보다는 method의 역할으로서 효율적이라고 생각한다. 결국 본 연구에서는 정렬 알고리즘을
						<br>
						확률적 개념과 결합하여 정렬을 하는 좋은 방식이 존재하는가라는 의문을 제시하고 그를 해결하기 위해 여러가지 방법을 생각해보았다.
					</p>
				</div>
			</section>
		</div>
		<div class="bor">
			<section>
				<div class="content">
					<ul><li><h3>소감</h3></li></ul>
					<p>
						-이 연구를 진행하면서 내가 생각하지 못하거나 힘들 것이라고 생각되는 여러가지 알고리즘에 대해 찾아보게 되었고 각 정렬 알고리즘의 특징과 원리뿐만 아니라
						<br>
						평소 찾아보던 자료구조에 대해 더 잘 이해할 수 있었다. 그리고 이 연구에 넣어놓지는 않았지만 그 외에도 Gravity Sort, Counting Sort 등등에 대해 알게 되어서
						<br>
						많은 정렬 알고리즘에 대한 시각화를 보며 조금 더 새로운 관점으로 어떤 알고리즘의 토대를 바라볼 수 있게 되었다. 
					</p>
				</div>
			</section>
		</div>	
		<div class="bor">
			<section>
				<div class="content">
					<ul><li><h3>참고문헌</h3></li></ul>
					<p> 
						<a href="https://www.codeit.kr/paths/skill/intro-to-python-programming?categoryId=62c288e9672c77328d2aa4a7&utm_source=google_paid&utm_medium=pmax&utm_campaign=da_purchase&utm_content=general&gclid=Cj0KCQjwxMmhBhDJARIsANFGOSs3UL4PADz1yYAkEDYAFp2FAQAVUViICMc7OUSGwlZ_zM8sJ0Z7WvIaAgLgEALw_wcB">코드잇 파이썬 강의</a>
						<br>
						<a href="https://namu.wiki/w/%EC%A0%95%EB%A0%AC%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">정렬 알고리즘1</a>
						<br>
						<a href="https://hsp1116.tistory.com/33">정렬 알고리즘2</a>
						<br>
						<a href="https://ko.wikipedia.org/wiki/%EA%B2%B0%EC%A0%95%EB%A1%A0%EC%A0%81_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">결정론적 알고리즘</a>
						<br>
						<a href="https://ko.wikipedia.org/wiki/%ED%99%95%EB%A5%A0%EC%A0%81_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">확률적 알고리즘</a>
						<br>
						<a href="https://ko.wikipedia.org/wiki/%EB%B0%80%EB%9F%AC-%EB%9D%BC%EB%B9%88_%EC%86%8C%EC%88%98%ED%8C%90%EB%B3%84%EB%B2%95">밀러 라빈 소수 판별법</a>

					</p>
				</div>	
			</section>
		</div>
	</div>
    <footer>
        <p>&copy; 2023/04/08 by WooMin. All rights reserved.</p>
    </footer>
</body>
</html>
