<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Text-based Adventure Game</title>
<link rel="stylesheet" href="../GamePage/styles.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Diphylleia&family=Nanum+Brush+Script&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Diphylleia&family=Nanum+Brush+Script&family=Orbit&display=swap" rel="stylesheet">
</head>
<body>
<div id="player-ui">
  <h2>Player</h2>
  <div id="status">
    Status: <br>
    Power: <span id="power">10</span><br>
    Intelligence: <span id="intelligence">10</span><br>
    Speed: <span id="speed">10</span><br>
    Attraction: <span id="attraction">10</span>
  </div>
  <br>
  <div id="inventory">Inventory: <br>
    <span id="items">검, 방패</span>
  </div>
</div>
<div id="game-ui">
  <div id="text"></div>
  <div id="choices"></div>
</div>
<script type="module">
  const gameData = {
    scene1: {
      text: `우민은 소박한 마을에서 평온한 생활을 하며, 사랑하는 아내 아리스와 함께 소박하면서도 행복한 일상을 즐기고 있었다. 그러나 어느 날, 아리스가 무서운 병에 걸리게 되어 그의 세상은 무너지게 된다. 병의 진행은 빠르고 무자비했다. 우민은 끝없는 암흑 속에서 그저 불공평한 운명을 저주할 뿐이었다.

      마을의 전설에 따르면, 이 세상 어딘가에는 던전이 있고, 그 던전의 끝에 도달하는 자는 소원을 이루어줄 수 있는 힘이 있다고 했다. 우민은 아리스를 되살리기 위해 던전을 향해 발걸음을 내디뎠다. 그의 여정은 0층, 거주가능지역에서 시작된다. 이곳은 평화롭고 조용한 초원 지역으로, 우민의 집이 위치해 있었다. 그는 기본적인 준비를 마치고 던전의 입구로 향했다. 던전의 입구는 오래된 광산인 1층으로 이어졌다. 이곳은 우민에게는 낯설고 불안한 곳이었다. 그러나 그는 던전의 깊숙한 곳에 숨겨진 소원을 이루어줄 힘을 찾아야만 했다.`,
      choices: {
        attack: { text: "공격", nextScene: "scene2", statusChange: { power: -1 }, items: ["드래곤 가죽"], limitStatus: { power: 1 }, limitItems: ["검"]},
        run: { text: "도망", nextScene: "scene3", statusChange: { speed: -1 }, limitStatus: { speed: 1 }},
        talk: { text: "대화", nextScene: "scene4", statusChange: { intelligence: 1 }, limitStatus: { intelligence: 1 }}
      }
    },
    scene2: {
      text: "당신은 검을 휘둘렸습니다. 결국 드래곤을 쓰러트리셨습니다!",
      choices: {
        continue: { text: "계속하기", nextScene: "scene1" }
      }
    },
    scene3: {
      text: "당신은 안전하게 도망을 가는데 성공하셨습니다.",
      choices: {
        continue: { text: "계속하기", nextScene: "scene1" }
      }
    },
    scene4: {
      text: "당신은 드래곤과 대화를 나누었습니다. 드래곤과 친구가 되었습니다!",
      choices: {
        continue: { text: "계속하기", nextScene: "scene1" }
      }
    },
    currentScene: "scene1",
    playerInventory: ["검", "방패"],
  };

  function updateScene() {
    const scene = gameData[gameData.currentScene];
    document.getElementById('text').innerText = scene.text;
    const choicesDiv = document.getElementById('choices');
    choicesDiv.innerHTML = '';
    for (const choiceKey in scene.choices) {
        const choice = scene.choices[choiceKey];
        const button = document.createElement('button');
        button.innerText = choice.text;
        button.onclick = () => makeChoice(choiceKey);
        
        // 버튼 활성화 여부
        let choiceEnabled = true;

        // 만약 status 부족이라면 선택지 비활성화
        if (choice.limitStatus) {
            for (const [statusKey, requiredValue] of Object.entries(choice.limitStatus)) {
                const statusElement = document.getElementById(statusKey);
                const currentStatusValue = parseInt(statusElement.innerText);
                if (currentStatusValue < requiredValue) {
                    choiceEnabled = false;
                    break;
                }
            }
        }

        // 만약 아이템이 없다면 선택지 비활성화
        if (choice.limitItems) {
            for (const requiredItem of choice.limitItems) {
                if (!gameData.playerInventory.includes(requiredItem)) {
                    choiceEnabled = false;
                    break;
                }
            }
        }

        button.disabled = !choiceEnabled;
        choicesDiv.appendChild(button);
    }
  }


  function makeChoice(choiceKey) {
    const choice = gameData[gameData.currentScene].choices[choiceKey];

    if (choice.nextScene) {
        gameData.currentScene = choice.nextScene;
        updateScene();
    }

    const currentSceneData = gameData[gameData.currentScene];

    if (choice && choice.nextScene && gameData[choice.nextScene]) {
        gameData.currentScene = choice.nextScene;

        // 선택지에 따른 status 변경
        if (choice.statusChange) {
            const statusChange = choice.statusChange;
            for (const [statusKey, changeAmount] of Object.entries(statusChange)) {
                const statusElement = document.getElementById(statusKey);
                const currentStatusValue = parseInt(statusElement.innerText);
                statusElement.innerText = currentStatusValue + changeAmount;
            }
        }

        // 선택지에 따른 아이템 추가
        if (choice.items) {
            gameData.playerInventory.push(...choice.items);
            document.getElementById('items').innerText = gameData.playerInventory.join(', ');
        }

        // 선택지에 따른 아이템 제거
        if (choice.removeItem) {
            for (const item of choice.removeItem) {
                const itemIndex = gameData.playerInventory.indexOf(item);
                if (itemIndex !== -1) {
                    gameData.playerInventory.splice(itemIndex, 1);
                }
            }
            document.getElementById('items').innerText = gameData.playerInventory.join(', ');
        }

        updateScene();
    } else {
        console.error('Invalid choice or next scene not defined:', choiceKey);
    }
  }

  updateScene();
</script>
</body>
</html>
