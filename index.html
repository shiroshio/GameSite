<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Text-based Adventure Game</title>
<link rel="stylesheet" href="styles.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Diphylleia&family=Nanum+Brush+Script&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Diphylleia&family=Nanum+Brush+Script&family=Orbit&display=swap" rel="stylesheet">
</head>
<body>
<div id="player-ui">
  <h2>Player</h2>
  <div id="status">
    Status: <br>
    Power: <span id="power">10</span><br>
    Intelligence: <span id="intelligence">10</span><br>
    Speed: <span id="speed">10</span><br>
    Attraction: <span id="attraction">10</span>
  </div>
  <br>
  <div id="inventory">Inventory: <br>
    <span id="items">검, 방패</span>
  </div>
</div>
<div id="game-ui">
  <div id="text"></div>
  <div id="choices"></div>
</div>
<script type="module">
  const gameData = {
    scene1: {
      text: "당신은 드래곤을 만났습니다. 무엇을 하시겠습니까?",
      choices: {
        attack: { text: "공격", nextScene: "scene2", statusChange: { power: -1 }, items: ["드래곤 가죽"], limitStatus: { power: 1 }, limitItems: ["검"]},
        run: { text: "도망", nextScene: "scene3", statusChange: { speed: -1 }, limitStatus: { speed: 1 }},
        talk: { text: "대화", nextScene: "scene4", statusChange: { intelligence: 1 }, limitStatus: { intelligence: 1 }}
      }
    },
    scene2: {
      text: "당신은 검을 휘둘렸습니다. 결국 드래곤을 쓰러트리셨습니다!",
      choices: {
        continue: { text: "계속하기", nextScene: "scene1" }
      }
    },
    scene3: {
      text: "당신은 안전하게 도망을 가는데 성공하셨습니다.",
      choices: {
        continue: { text: "계속하기", nextScene: "scene1" }
      }
    },
    scene4: {
      text: "당신은 드래곤과 대화를 나누었습니다. 드래곤과 친구가 되었습니다!",
      choices: {
        continue: { text: "계속하기", nextScene: "scene1" }
      }
    },
    currentScene: "scene1",
    playerInventory: ["검", "방패"],
  };

  function updateScene() {
    const scene = gameData[gameData.currentScene];
    document.getElementById('text').innerText = scene.text;
    const choicesDiv = document.getElementById('choices');
    choicesDiv.innerHTML = '';
    for (const choiceKey in scene.choices) {
        const choice = scene.choices[choiceKey];
        const button = document.createElement('button');
        button.innerText = choice.text;
        button.onclick = () => makeChoice(choiceKey);
        
        // 버튼 활성화 여부
        let choiceEnabled = true;

        // 만약 status 부족이라면 선택지 비활성화
        if (choice.limitStatus) {
            for (const [statusKey, requiredValue] of Object.entries(choice.limitStatus)) {
                const statusElement = document.getElementById(statusKey);
                const currentStatusValue = parseInt(statusElement.innerText);
                if (currentStatusValue < requiredValue) {
                    choiceEnabled = false;
                    break;
                }
            }
        }

        // 만약 아이템이 없다면 선택지 비활성화
        if (choice.limitItems) {
            for (const requiredItem of choice.limitItems) {
                if (!gameData.playerInventory.includes(requiredItem)) {
                    choiceEnabled = false;
                    break;
                }
            }
        }

        button.disabled = !choiceEnabled;
        choicesDiv.appendChild(button);
    }
  }


  function makeChoice(choiceKey) {
    const choice = gameData[gameData.currentScene].choices[choiceKey];

    if (choice.nextScene) {
        gameData.currentScene = choice.nextScene;
        updateScene();
    }

    const currentSceneData = gameData[gameData.currentScene];

    if (choice && choice.nextScene && gameData[choice.nextScene]) {
        gameData.currentScene = choice.nextScene;

        // 선택지에 따른 status 변경
        if (choice.statusChange) {
            const statusChange = choice.statusChange;
            for (const [statusKey, changeAmount] of Object.entries(statusChange)) {
                const statusElement = document.getElementById(statusKey);
                const currentStatusValue = parseInt(statusElement.innerText);
                statusElement.innerText = currentStatusValue + changeAmount;
            }
        }

        // 선택지에 따른 아이템 추가
        if (choice.items) {
            gameData.playerInventory.push(...choice.items);
            document.getElementById('items').innerText = gameData.playerInventory.join(', ');
        }

        // 선택지에 따른 아이템 제거
        if (choice.removeItem) {
            for (const item of choice.removeItem) {
                const itemIndex = gameData.playerInventory.indexOf(item);
                if (itemIndex !== -1) {
                    gameData.playerInventory.splice(itemIndex, 1);
                }
            }
            document.getElementById('items').innerText = gameData.playerInventory.join(', ');
        }

        updateScene();
    } else {
        console.error('Invalid choice or next scene not defined:', choiceKey);
    }
  }

  updateScene();
</script>
</body>
</html>
